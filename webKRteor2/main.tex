\documentclass{article}
\usepackage[utf8]{inputenc} %кодировка
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel} %русификатор 
\usepackage{mathtools} %библиотека матеши
\usepackage[left=1cm,right=1cm,top=1cm,bottom=0cm,bindingoffset=0cm]{geometry} %изменение отступов на листе
\usepackage{amsmath}
\usepackage{graphicx} %библиотека для графики и картинок
\graphicspath{}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\usepackage{subcaption}
\usepackage{pgfplots}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{graphicx} %библиотека для графики и картинок
\graphicspath{}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\usepackage{subcaption}
\usepackage{pgfplots}
\usepackage{amssymb}
\usepackage{physics}

\newcommand{\bil}[4]{%
    \begin{minipage}{.3\textwidth}
        \textbf{1. #1} \\
        \textbf{2. #2}

        1. #3
        \\
        2. #4
    \end{minipage}
}

\begin{document}
\begin{center}
    \LaTeX
\end{center}
\tiny
\bil{Компоненты в Angular: взаимодействие с представлениями и сервисами}{Инициализация Spring Beans}{
    В модулях определяются компоненты. Компоненты — строительные блоки интерфейса, кирпичики, инкапсулирующие верстку, стили, и логику приложения, которые можно переиспользовать внутри других компонентов. 
    Любой компонент состоит из TS класса, помеченного декоратором @Component, HTML шаблона, CSS стилей. 
    Компонент вместе с шаблоном образуют представление. Представления образуют иерархию. 
    Существует двухсторонняя связь между классом компонента и представлением — при изменении данных в компоненте обновляется представление и наоборот.
    Задачи приложения, которые не касаются представления, выносятся в сервисы.
    Angular поддерживает DI: сервисы внедряются в компоненты (аннотация @Injectable).
}{
    Инициализация. Разные способы применяются в таком порядке: Метод бина с аннотацией @PostConstruct из стандарта JSR-250 (рекомендуемый способ); Метод afterPropertiesSet() бина реализующего интерфейс InitializingBean;
    Init-метод. Для отдельного бина его имя устанавливается в параметре определения initMethod. В xml-конфигурации можно установить для всех бинов сразу, с помощью default-init-method.
    Могут быть использованы в JSF путём конфигурации в faces-config.xml
}
\hfill
\bil{Фаза Apply request values JSF}{Реализация IoC и CDI в Spring}{
    Данная фаза идёт после фазы формирования представления и до фазы валидации значений компонентов.
    На стороне клиента все значения хранятся в строковом формате, поэтому нужна проверка их корректности: 
    Вызывается конвертер в соответствии с типом данных значения.
    Если конвертация - успешно, значение сохраняется в локальной переменной компонента.
}{
    Инверсия управления — принцип для уменьшения связности кода. Самописным кодом управляет фреймворк, занимающийся жизненным циклом компонентов и коммуникацией между ними. Реализуется посредством внедрения зависимостей.
    Внедрение зависимостей - паттерн проектирования, который позволяет создавать объект, использующий другие объекты. При этом поля объекта настраиваются внешней сущностью. 
    Позволяет убрать зависимость компонента от контейнера.
    ApplicationContext контейнер, который тоже управляет жизненным циклом компонентов и коммуникацией между ними и также реализуется посредством внедрения зависимостей, которые реализуется через аннотации.
    @Autowired - внедрение. Spring IoC контейнеру требуются метаданные для конфигурации. Для этого классы помечаются аннотацией @Component, а также её наследниками @Repository, @Service и @Controller
}
\hfill
\bil{Spring MVC: handler mapping}{JSX. Применение в реакте. Пример синтаксиса}{
    Когда DispatcherServlet получает запрос, он на основании конфигурации HandlerMapping выбрать на какой контроллер пойдет запрос. 
    Этот mapping - механизм, позволяющий распределять запросы по различным обработчикам. Помимо основного Handler'а, в обработке
    запроса могут участвовать реализаций интерфейса HandlerInterceptor. Механизм в общем похож на сервлеты и
    фильтры. Из коробки программисту доступно несколько реализаций Handler Mapping.
}{
    React представляет собой дерево из компонентов. 
    Точкой входа (корнем) являет index.js который определяет компоненты. 
    Каждый компонент включает в себя другие компоненты.
    В React приложениях разметка пишется в JSX файлах. JSX — надстройка над JS, которая позволяет вкраплять HTML-синтаксис в код. 
    Можно использовать стандартные HTML элементы (такие как div, span, h1, input) так и кастомные React компоненты.
    function warningButton()\{return <CustomButton color="кровиВТшников" />\}
}
\\
\bil{Реализация Ajax в JSF}{CDI beans: контекст (Bean Scope)}{
1 способ: JavaScript API - jsf.ajax.request(); event - событие, по которому отправляется AJAX-запрос
; execute - компоненты, обрабатываемые в цикле обработки запроса
; render - перерисовываемые компоненты.
<h:commandButton id="submit" value="submit"
onclick="jsf.ajax.request(this, event, \{execute: 'myinput', render: 'outtext'\});/>.
2 способ: 
<h:commandButton id='submit', value='submit'> <f:ajax execute="@form" render="msg"/></h:commandButton>
}{Определяет жизненный цикл бинов и их видимость друг для друга.
    @RequestScoped - контекст - запрос;
@ViewScoped - контекст-страница(компонент создается один раз при обращении к странице, и используется ровно столько, сколько пользователь находится на странице); из JSF, но тоже работает;
@SessionScoped - контекст - сессия;
@ApplicationScoped - контекст - приложение;
@ConversationScoped - Областью жизни управляет программист. Управление осуществляется через инъекцию объекта javax.enterprise.context.Conversation;
@Dependent.  Используется по умолчанию. ЖЦ определяется тем где он был использован;}
\hfill
\bil{Фазы jsf: Invoke Application и Render Response}{Способы задания конфигурации в Spring}{
    При поступлении запроса необходимо выполнить определенную цепочку действий, чтобы проанализировать запрос и подготовить ответ. За программиста это делает фреймворк(JSF)
    Invoke Application Phase: Управление передаётся слушателям событий, JSF обрабатывает события  также решается вопрос навигации; Формируются новые значения компонентов.
    (Вызывается метод UIViewRoo\#processApplication() для обработки событий.)
    Render Response Phase: JSF Runtime обновляет представление в соответствии с результатами обработки запроса; Если это первый запрос к странице, то компоненты помещаются в иерархию представления; Формируется ответ сервера на запрос; На стороне клиента происходит обновление страницы. 
}{
    XML-файл, в котором вручную прописываются все бины, путь до класса, свойства, конструкторы. Загружается этот файл из classpath; 
    (class based config). Создаем класс с аннотацией Configuration, внутри помечаем методы аннотацией Bean; 
    (annotation based config) добавляя к классам аннотации Component и т.д. Внедрение зависимостей происходит через аннотацию Autowired; 
    Groovy config;
    Property files;
    2 и 3 - java config;
}
\hfill
\bil{MVC в JSF}{Главные аннотации в CDI beans java EE}{
    Model — бины, в которых содержится бизнес логика. 
View — xhtml шаблон в котором формируется дерево компонентов. Компоненты могут взаимодействовать с бинами, вызывать их методы или получать из них данные, тем самым передавая их пользователю.
Controller — реализуется самим фреймворком. Это класс FacesServlet, который занимается диспетчеризацией и управлением жизненным циклом.
}{
    @RequestScoped - контекст - запрос;
    @ViewScoped - контекст-страница;
    @SessionScoped - контекст - сессия;
    @ApplicationScoped - контекст - приложение;
    @ConversationScoped - Областью жизни управляет программист. Управление осуществляется через инъекцию объекта context.Conversation;
    @Dependent.  Используется по умолчанию. ЖЦ определяется тем где он был использован;
    @Produces/@Disposes, бины - фабрики которые управляют экземплярами других бинов;
    @Informal — бин-наследник;
    @Inject - используется для указания точки внедрения зависимости. Инъекции могут происходить в поле, в метод и в конструкторе;
    @Named - используется, для того, чтобы выдать имя бину, тогда его можно будет использовать на jsf странице;
    @Qualifier - аннотация, которая используется для создания аннотаций-спецификаторов, которые четко указывают, какой бин надо инжектить. Над классом ставится аннотация для указания квалификатора бина. Над точкой внедрения ставится такая же аннотация;
    @Default/Alternative — управляет выбором бина при наличии нескольких
}
\\
\bil{Spring Web MVC: View Resolvers}{Angular: ключевые особенности, отличия от AngularJS}{
    Контроллер после обработки запроса возвращает имя представления на которое нужно направить пользователя. View Resolver — интерфейс, реализуемый объектами, которые способны находить представление по его имени. 
    С помощью него Dispatcher Servlet находит нужный View.
    Представление в Spring Web MVC может быть построено на разных технологиях.
    С каждым представлением сопоставляется его символическое имя.
    Преобразованием символических имён в ссылки на конкретные представления занимается специальный класс, реализующий интерфейс ViewResolver. 
    Существует много реализаций ViewResolver для разных технологий построения представления. 
    В одном приложении можно использовать несколько ViewResolver'ов
}{
    Angular - написана на TypeScript, развитие AngularJS
    особенности:
    кроссплатформенное;
    для разработки надо настроить сборочное окружение;
    приложение состоит из модулей (NgModules);
    модули обеспечивают контекст для компонентов;
    из компонентов строятся представления;
    компоненты взаимодействуют с сервисами через DI;
    Angular как и AngularJS реализуют модель MVVM.
    В AngularJS жесткие рамки для компонентов; есть иерархия компонентов; гораздо менее безопасен и управляем; задействует JavaScript, Angular же использует TypeScript.
    Angular адаптирован под слабые мобильные устройства.

}
\hfill
\bil{Профили и платформы Java EE}{Типы DI в Spring}{
    Web Profile — содержит в себе только те компоненты, которые нужны для работы веб приложения, это Servlet, JSP, JSF, JPA, CDI, EJB.
Full Profile — полный сборник джавы ее, в нем есть еще JAX-RS, JAX-WS, JAXB, JNDI, JAVA MAIL.
Платформы: JME- представляет из себя API и минимально требовательную VM для разработки и старта приложения на смартфоне/планшете. JSE- занимается обеспечением основными стандартными функциями самой Java, и она определяет: базовые типы и объекты языка, классы более высокого уровня, 
производительность приложения в сети и обеспечение защищенности.
JEE- для разработки Enterprise приложений. Она строится на основе платформы JSE, а еще дает возможность разработки более крупно масштабируемых, сложно уровневых и безопасных программ. Содержит: WebSocket, JSF, Unified EL, API для веб-служб RESTful, DI, EJB, JPA, и Java Transaction API.
}{
    Constructor-based DI - контейнер вызовет конструктор с аргументами бинов, которые потом заинджектятся в класс; Setter-based DI - сначала контейнер вызовет конструктор бина без аргументов, после вызовет помеченные аннотациями @Autowired сеттеры и впихнет туда нужные зависимости; 
    Field-based DI - контейнер через рефлексию будет в поля класса пропихивать зависимости.
}
\hfill
\bil{Структура JSF приложения}{Spring MVC: особенности, интеграция в Spring}{
    JSP или XHTML - страницы содержащие компоненты GUI. JSP или XHTML представляют из себя обычный HTML, но со своими тэгами и префиксами.
Для этого в стандартной структуре jsf есть:
Библиотека тэгов - они описывают эти дополнительные тэги jsf;
Управляемые бины - бины управляемые рантаймом jsf (контейнером), чем является faces Servlet;
Дополнительные объекты (компоненты, конверторы и валидаторы);
Дополнительные тэги;
Конфигурация - faces-config.xml (опционально);
Дескриптор развертывания - как и для любого веб приложения;
}{
    Spring Web MVC – фреймворк в составе Spring для разработки веб-приложений.
    Основан на паттерне MVC.
    Model инкапсулирует данные приложения, в целом они будут состоять из POJO.
    View отвечает за отображение данных фрэймворк не специфицирует жестко технологию на которой будет построено представление. По умолчанию JSP.
    Controller обрабатывает запрос пользователя, создаёт соответствующую Модель и передаёт её для отображения на View.
Back-end; универсальный, удобен для разработки REST API. На клиентской стороне интегрируется с популярными JS-фреймворками.
Удобно интегрируется с Thymeleaf.

}
\\
\bil{Spring MVC: обработка запросов, DispatcherServlet}{Single Page Application(SPA): преимущества, недостатки}{
    Вся логика работы Spring MVC построена вокруг DispatcherServlet, который принимает и обрабатывает все HTTP-запросы и ответы на них. При получении запроса, происходит следующая цепочка событий: 
DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет какой контроллер должен быть вызван. 
Контроллер принимает запрос и вызывает соответствующий служебный метод (GET, POST), который возвращает в диспатчер имя View.
При помощи ViewResolver диспатчер определяет, какой View надо использовать на основании полученного имени.
После того, как View создан, диспатчер отправляет данные модели в виде атрибутов, которые уже в конечном итоге отображаются в браузере.
}{
    Веб-приложение, использующее единственный HTML-документ как оболочку для всех веб-страниц и динамически подгружает HTML, CSS, JS, обычно посредством AJAX. За навигацию отвечает JS.
    Клиент и сервер реализуются независимо и взаимодействуют по REST(обычно JSON). 
    Преимущества: легкость создания из-за огромного количества готовых библиотек и фреймворков;
    Простое кэширование данных;
    Скорость работы, основная часть ресурсов уже загружена, на страничку подгружаются только необходимые данные.
    Недостатки: 
    Тяжелые клиентские фреймворки;
    Без JS невозможно пользоваться полным функционалом приложения;
    Недоступна SEO оптимизация.
}
\hfill
\bil{Технология RMI. Использование RMI в Java EE}{Управление состоянием в React. Flux and Redux}{
    Система RMI позволяет объекту, запущенному на одной виртуальной машине Java, вызывать методы объекта, запущенного на другой виртуальной машине Java. Работает поверх TCP. В общем случае, объекты передаются по значению, передаваемые объекты должны быть Serializable.
    Использование: Регистрируем серверный объект RMI Registry; Далее создается заглушка, реализующая тот же интерфейс что и серверный объект, отправляется клиенту и притворяется, что все методы есть;
При вызове происходит поиск объекта сервера;
Клиенту прилетает ответ;
Происходит обмен данными;
}{
    Flux — архитектура для создания приложений на React, в которой описывается, как хранить, изменять и отображать глобальные данные.
Основные концепции: Dispatcher принимает события от представления и отправляет их на обработку хранилищу данных. Store знает, как менять данные. Напрямую из React-компонента их изменить нельзя. После изменения данных Store посылает события представлению, и оно перерисовывается.
Redux — небольшая библиотека, реализующая упрощенный паттерн Flux. В Redux есть store — синглтон, хранилище состояние всего приложения. Изменения состояния производятся при помощи чистых функций. Они принимают на вход state и действиеи возвращают либо неизмененный state либо копию
}
\hfill
\bil{JNDI. JNDI в Java EE. Способы взаимодействия с JNDI. Их преимущества и недостатки.}{React. Особенности. Архитектура}{
    JNDI — API для доступа к объектам и ресурсам по их именам. Организовано в виде службы имен и каталогов.
    Чаще всего используется в enterprise. Главный юзкейс — настройка доступа к базе данных. Приложение знает только JNDI-имя, а сами детали подключения описываются администратором в веб контейнере.
    JNDI поддерживает разные реализации сервиса служб имен и каталогов. Некоторые из них: DNS, RMI, LDAP, COBRA. 
    Преимущества JNDI: пароли к бд лежат отдельно от приложения; при изменении бд не нужно пересобирать приложение.
    Недостатки: зависимость от контейнера; при использовании старой версии log4j есть уязвимость (log4shell) основанная на jndi.
    Варианты использования: CDI аннотации, работает только в managed компонентах; прямой вызов API, работает везде. new InitialContext().lookup(“res”);
}{
    React — JS библиотека для разработки пользовательского интерфейса (SPA). Позволяет создавать свои собственные компоненты, с пропсами и стейтом. Компоненты рендерятся в HTML.
    Передача данных от родителя к детям. Виртуальный DOM. При изменении state происходит ререндер компонента с обновлением вложенных компонентов/тэгов.
    При написании сложных приложений, работающих с большим количеством данных, часто применяется архитектура Flux и библиотека Redux.
}
\\
\bil{Платформы Java. Сходства и различия.}{Двухфазные и трехфазные конструкторы в Spring и Java EE}{
Java Micro Edition представляет из себя API и минимально требовательную VM для разработки и старта приложения на смартфоне. Основана на более ранней версии JSE, поэтому некоторые функции не работают
Java Standard Edition занимается обеспечением основными стандартными функциями самой Java, и она определяет абсолютно все: базовые типы и объекты языка, классы более высокого уровня, производительность приложения в сети и обеспечение защищенности.
Java Enterprise Edition для разработки Enterprise приложений. Она строится на основе платформы JSE, а еще дает возможность разработки более крупно масштабируемых, сложно уровневых и безопасных программ. Содержит: WebSocket, JSF, Unified EL, API для RESTful, DI, EJB, JPA, и Java Transaction API.
Все платформы Java поддерживают полный функционал языка Java и отличаются лишь наличием или отсутствием определенных API.
}{
    Двухфазовые: обычный конструктор + метод с аннотацией @PostConstruct. 
    Сначала вызовется обычный конструктор, а затем помеченный метод. 
    На момент его вызова все зависимости будут обработаны и доступны.
    Трехфазовый: сначала был нативный конструктор, потом обработались зависимости, уже с обработанными зависимостями вызвалось конструирование объекта, а потом добавились срезы. 
Аспекты - это “вкрапления”, которые позволяют добавить поведение до/после вызова оригинального метода через Proxy
Такой конструктор имеет свой скоуп.
}
\hfill
\bil{Валидаторы в JSF. Создание, назначение и тд.}{Реализация контроллера в Spring Web MVC}{
    Валидаторы в JSF — реализации интерфейса Validator. Метод validate принимает FacesContext, UiComponent и значение.
    Осуществляется перед обновлением значения компонента на уровне модели. Класс, осуществляющий валидацию, должен реализовывать 
    интерфейс javax.faces.validator.Validator. Существуют стандартные валидаторы для основных типов данных.  
    DoubleRangeValidator, LengthValidator, RegexValidator, RequiredValidator. Cобственные валидаторы c помощью аннотации @FacesValidator.
    Создание: параметры компонента, вложенный тег, <f:validatorvalidatorId=”com.example.MyValidator”/>, логика на уровне управлямого бина
}{
    Перехватывает входящие запросы, упаковывает данные в нужный формат, отправляет эти данные нужной модели, а затем ответ от модели передать обратно в DispatcherServlet. 
    На методы контроллера лепятся разные аннотации(@GetMapping, @PostMapping, @PathVariable. @ResourcesVarible).
    @Controller $\aleph$ public class HelloController \{ $\aleph$ @RequestMapping(value = "/hello", method = RequestMethod.GET)$\aleph$ 
    public String printHello(ModelMap  model) \{$\aleph$ 
    model.addAttribute("message", "Hello Spring MVC Framework!");$\aleph$
    return "hello";\}\}
}
\hfill
\bil{JSF Restore View phase}{Spring Framework. Отличия и сходства с JavaEE}{
    Restore View phase происходит до Apply Request Values Phase.
    JSF Runtime формирует представление (начиная сUIViewRoot): Создаются объекты компонентов. Назначаются слушатели событий, конвертеры и валидаторы.
    Все элементы представления помещаются в FacesContext.
    Если это первый запрос пользователя к странице JSF, то формируется пустое представление.
    Если это запрос к уже существующей странице, то JSF Runtime синхронизирует состояние компонентов представления с клиентом.
}{
    Универсальный фреймворк для разработки приложений на Java.
    Реализует паттерн IoC и механизмы CDI.
    Активно использует инфраструктурные решения Java / Jakarta EE.
    Базовая концепция Java EE – разделение обязанностей между контейнером и компонентом; «базовая» концепция Spring – IoC / CDI.
    Контейнер в Java EE включает в себя приложение; приложение в Spring включает в себя контейнер.
    Java EE – спецификация; Spring – фреймворк.
}
\\
\bil{Java EE CDI Beans прерывание жизненного цикла (Interception)}{Компоненты React. State and props. Умные и Глупые компоненты}{123}{123}
\hfill
\bil{REST контроллеры в спринге. Сериализация и десериализация}{Архитектура Angular приложения. Модули, компоненты, представление, сервисы}{123}{123}
\hfill
\bil{JavaServer Faces. Особенности, недостатки, преимущества.}{CDI бины - что это, зачем нужны, если есть EJB и ManagedBeans}{123}{123}
\\
\bil{Построение интерфейсов на JSF. Иерархия компонентов JSF.}{Java EE CDI Beans: принципы инъекции бинов.}{123}{123}
\hfill
\bil{Managed bean: назначение, конфигурация, использование в xhtml}{Архитектура и состав Spring Web MVC}{123}{123}
\hfill
\bil{Контекст управляемых бинов. Конфигурация контекста бина}{Шаблоны MVVM и MVP. Сходства и отличия от MVC }{123}{123}
\\
\bil{REST в спринге: методы и аргументы}{Навигация в React. React Router}{123}{123}
\hfill
\bil{Класс FacesServlet - назначение, особенности конфигурации}{Vue.js - ключевые особенности, преимущества и недостатки}{123}{123}
\hfill
\bil{Конвертеры JSF, создание и назначение}{Реализация model в Spring web MVC}{123}{123}
\\
\bil{CDI Beans }{Angular DI}{123}{123}
\hfill
\bil{Шаблоны и представление в Angular }{Dependency Lookup Spring}{123}{123}
\hfill
\bil{Process validations phase, Update module values phase}{Жизненный цикл Spring-приложения}{123}{123}
\end{document}





\bil{}{}{123}{123}
\hfill
\bil{}{}{123}{123}
\hfill
\bil{}{}{123}{123}